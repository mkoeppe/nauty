Description: system preprocessing directive #include for examples
Origin: debian
Author: Jerome Benoit <calculus@rezozer.net>
Last-Update: 2013-11-24

--- a/nautyex1.c
+++ b/nautyex1.c
@@ -5,7 +5,7 @@
 */
 
 #define MAXN 1000    /* Define this before including nauty.h */
-#include "nauty.h"   /* which includes <stdio.h> and other system files */
+#include <nauty/nauty.h>   /* which includes <stdio.h> and other system files */
 
 int
 main(int argc, char *argv[])
--- a/nautyex10.c
+++ b/nautyex10.c
@@ -6,7 +6,7 @@
    those here, it can be faster for some very difficult graphs.
 */
 
-#include "traces.h"
+#include <nauty/traces.h>
 
 int
 main(int argc, char *argv[])
--- a/nautyex2.c
+++ b/nautyex2.c
@@ -4,7 +4,7 @@
    This version uses dynamic allocation.
 */
 
-#include "nauty.h"   
+#include <nauty/nauty.h>
 /* MAXN=0 is defined by nauty.h, which implies dynamic allocation */
 
 int
@@ -13,7 +13,7 @@
   /* DYNALLSTAT declares a pointer variable (to hold an array when it
      is allocated) and a size variable to remember how big the array is.
      Nothing is allocated yet.  */
- 
+
     DYNALLSTAT(graph,g,g_sz);
     DYNALLSTAT(int,lab,lab_sz);
     DYNALLSTAT(int,ptn,ptn_sz);
--- a/nautyex3.c
+++ b/nautyex3.c
@@ -1,9 +1,9 @@
 /* This program prints the entire automorphism group of an n-vertex
-   polygon, where n is a number supplied by the user. 
+   polygon, where n is a number supplied by the user.
 */
 
-#include "nauty.h"    /* which includes <stdio.h> */
-#include "naugroup.h"
+#include <nauty/nauty.h>    /* which includes <stdio.h> */
+#include <nauty/naugroup.h>
 
 /**************************************************************************/
 
@@ -33,7 +33,7 @@
 
  /* The following cause nauty to call two procedures which
         store the group information as nauty runs. */
-        
+
     options.userautomproc = groupautomproc;
     options.userlevelproc = grouplevelproc;
 
@@ -61,18 +61,18 @@
             structure will be "cut loose" so that it won't be used
             again the next time nauty() is called.  Otherwise, as
             here, the same structure is used repeatedly. */
-                
+
             group = groupptr(FALSE);
 
          /* Expand the group structure to include a full set of coset
             representatives at every level.  This step is necessary
             if allgroup() is to be called. */
-                
+
             makecosetreps(group);
 
          /* Call the procedure writeautom() for every element of the group.
             The first call is always for the identity. */
-                
+
             allgroup(group,writeautom);
         }
         else
--- a/nautyex4.c
+++ b/nautyex4.c
@@ -3,7 +3,7 @@
    This version uses sparse form with dynamic allocation.
 */
 
-#include "nausparse.h"    /* which includes nauty.h */
+#include <nauty/nausparse.h>    /* which includes nauty.h */
 
 int
 main(int argc, char *argv[])
--- a/nautyex5.c
+++ b/nautyex5.c
@@ -3,7 +3,7 @@
    This version uses sparse form with dynamic allocation.
 */
 
-#include "nausparse.h"    /* which includes nauty.h */
+#include <nauty/nausparse.h>    /* which includes nauty.h */
 
 int
 main(int argc, char *argv[])
@@ -24,7 +24,7 @@
  /* Select option for canonical labelling */
 
     options.getcanon = TRUE;
- 
+
  /* Read the number of vertices and process it */
 
     while (1)
@@ -58,7 +58,7 @@
                 sg1.v[i] = 3*i;     /* Position of vertex i in v array */
                 sg1.d[i] = 3;       /* Degree of vertex i */
             }
-             
+
             for (i = 0; i < n; i += 2)   /* Spokes */
             {
                 sg1.e[sg1.v[i]] = i+1;
@@ -74,7 +74,7 @@
                 sg1.e[sg1.v[i]+2] = i-2;
             sg1.e[sg1.v[1]+2] = n-2;
             sg1.e[sg1.v[0]+2] = n-1;
-                
+
          /* Now make the second graph */
 
             SG_ALLOC(sg2,n,3*n,"malloc");
@@ -99,7 +99,7 @@
          /* Label sg1, result in cg1 and labelling in lab1; similarly sg2.
             It is not necessary to pre-allocate space in cg1 and cg2, but
             they have to be initialised as we did above.  */
-            
+
             sparsenauty(&sg1,lab1,ptn,orbits,&options,&stats,&cg1);
             sparsenauty(&sg2,lab2,ptn,orbits,&options,&stats,&cg2);
 
--- a/nautyex6.c
+++ b/nautyex6.c
@@ -4,7 +4,7 @@
    This version uses dense form with dynamic allocation.
 */
 
-#include "nauty.h"
+#include <nauty/nauty.h>
 
 int
 main(int argc, char *argv[])
@@ -26,7 +26,7 @@
  /* Select option for canonical labelling */
 
     options.getcanon = TRUE;
- 
+
     while (1)
     {
         printf("\nenter n : ");
@@ -72,7 +72,7 @@
          /* Label g1, result in cg1 and labelling in lab1; similarly g2.
             It is not necessary to pre-allocate space in cg1 and cg2, but
             they have to be initialised as we did above.  */
-            
+
             densenauty(g1,lab1,ptn,orbits,&options,&stats,m,n,cg1);
             densenauty(g2,lab2,ptn,orbits,&options,&stats,m,n,cg2);
 
--- a/nautyex7.c
+++ b/nautyex7.c
@@ -3,7 +3,7 @@
    This version uses Traces.
 */
 
-#include "traces.h"
+#include <nauty/traces.h>
 
 int
 main(int argc, char *argv[])
@@ -24,7 +24,7 @@
  /* Select option for canonical labelling */
 
     options.getcanon = TRUE;
- 
+
  /* Read a number of vertices and process */
 
     while (1)
@@ -58,7 +58,7 @@
                 sg1.v[i] = 3*i;     /* Position of vertex i in v array */
                 sg1.d[i] = 3;       /* Degree of vertex i */
             }
-             
+
             for (i = 0; i < n; i += 2)   /* Spokes */
             {
                 sg1.e[sg1.v[i]] = i+1;
@@ -74,7 +74,7 @@
                 sg1.e[sg1.v[i]+2] = i-2;
             sg1.e[sg1.v[1]+2] = n-2;
             sg1.e[sg1.v[0]+2] = n-1;
-                
+
          /* Now make the second graph */
 
             SG_ALLOC(sg2,n,3*n,"malloc");
@@ -99,7 +99,7 @@
          /* Label sg1, result in cg1 and labelling in lab1; similarly sg2.
             It is not necessary to pre-allocate space in cg1 and cg2, but
             they have to be initialised as we did above.  */
-            
+
             Traces(&sg1,lab1,ptn,orbits,&options,&stats,&cg1);
             Traces(&sg2,lab2,ptn,orbits,&options,&stats,&cg2);
 
--- a/nautyex8.c
+++ b/nautyex8.c
@@ -3,7 +3,7 @@
    This version uses dense form with dynamic allocation.
 */
 
-#include "nauty.h" 
+#include <nauty/nauty.h>
 
 int
 main(int argc, char *argv[])
@@ -26,7 +26,7 @@
  /* Select option for canonical labelling */
 
     options.getcanon = TRUE;
- 
+
     while (1)
     {
         printf("\nenter n : ");
--- a/nautyex9.c
+++ b/nautyex9.c
@@ -2,12 +2,12 @@
    to Traces.  We compute the automorphism group of the circulant
    graph of order n with i is adjacent to j iff j-i is a square
    mod n.  We need that -1 is a square so that the graph is
-   undirected, which means that the prime factors of n must be 
+   undirected, which means that the prime factors of n must be
    congruent to 1 mod 4.  (This is the Paley graph in the event
    that p is a prime.)
 */
 
-#include "traces.h"
+#include <nauty/traces.h>
 
 int
 main(int argc, char *argv[])
@@ -29,7 +29,7 @@
  /* Select option for passing generators to Traces */
 
     options.generators = &gens;
- 
+
  /* Read a number of vertices and process it */
 
     while (1)
@@ -74,7 +74,7 @@
                 sg.v[i] = i*deg;     /* Position of vertex i in v array */
                 sg.d[i] = deg;       /* Degree of vertex i */
             }
-             
+
             for (i = 0; i < n; ++i)   /* Edges */
             {
                 k = sg.v[i];
@@ -99,7 +99,7 @@
             addpermutation(&gens,p,n);
 
          /* Call Traces */
-            
+
             Traces(&sg,lab,ptn,orbits,&options,&stats,NULL);
 
             printf("Automorphism group size = ");
