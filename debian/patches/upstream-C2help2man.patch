Description: format usages and helps
 Attempt to format usages and helps of the invited
 programs wrt to the original gtools.
Origin: debian
Author: Jerome Benoit <calculus@rezozer.net>
Last-Update: 2013-11-21

--- a/watercluster2.c
+++ b/watercluster2.c
@@ -1,55 +1,59 @@
 // cc -O4 -o water2 -DWORDSIZE=32 -DMAXN=WORDSIZE nauty.c naugraph.c nautil.c gtools.c schreier.c naurng.c watercluster2.c
 
-/*
-Reads graphs in g6 code or multicode (optional) from stdin and directs them 
-
-options: 
-
-ix  means: the indegree of every vertex may be at most x.
-
-iy  means: the outdegree of every vertex may be at most y.
-
-  S  means: allow that for every pair of vertices x,y at most one of the edges x-->y 
-     and y-->x may be present. By default both of them may be present in the same graph.
-
-
-  T  means: Output directed graphs in T-code. This is a simple ASCII output format. Every line
-     contains one graph. First the number of vertices, then the number of 
-     directed edges and then the list of directed edges with the start first 
-     and the end then. E.g.: 3 2 0 1 2 1 means 3 vertices, 2 directed edges:
-     0-->1 and 2-->1
+#define GTOOL_USAGEHELP_COMPATIBILITY
 
-  B  means: Output the directed graphs in a binary code. Every item of the code is an unsigned
-     char. The first unsigned char is the number nv of vertices. The vertices are numbered 1..nv
-     Then the list of vertices x for which there is a directed edge 1->x follow. This list is
-     ended by a 0. Then the list of outgoing neighbours of 2 follows -- again ended with a 0, etc.
-     The code is complete with the 0 ending the list of outgoing neighbours of nv.
+#define USAGE "watercluster2 [ix] [oy] [S] [T] [B] [C] [m]"
 
-  C  means: Do really construct all the directed graphs in memory, but don't output them. This is not
-     a big difference in case of restricted in- and outdegrees, because all that is done extra is that 
-     edges are directed instead of just keeping track of in- and out-degrees. This option is intended only
-     for testing purposes to test also routines that are normally not used when counting. Things that would 
-     speed up the counting also in some cases of restricted in- and out-degrees -- like multiplying the 
-     possibilities of assigning directions to edges that can be assigned directions independent 
-     of each other (depending on the degrees of the endvertices and overlaps) -- are not included. 
-     In case of not restrictive bounds on the in- and out-degree it not really constructing the graphs
-     can be considerably faster. In cases of restricted in- and out-degrees the only difference is that
-     the graph isn't modified...
-     The fact that in case of no output the graph is not modified is mainly to save time for the one 
-     case of waterclusters, where large numbers were determined. If large numbers (without output)
-     for other cases shall be determined, one should think about adding the multiplication routines.
-
-   m read multicode
-
-This program uses different labelling routines -- all based on the ideas of 
-
-G. Brinkmann, Generating water clusters and other directed graphs,
-Journal of Mathematical Chemistry 46, 1112--1121 (2009)
-
-October 10, 2011: corrected error caused by overflow of 32bit int used as hashvalue.
-
-Sep, 2012: PROCESS feature added by BDM.
-*/
+#define HELPTEXT \
+" Reads graphs in g6 code or multicode (optional) from stdin and directs them\n\
+\n\
+  ix : the indegree of every vertex may be at most x.\n\
+       The default maximum indegree is unlimited.\n\
+\n\
+  oy : the outdegree of every vertex may be at most y.\n\
+       The default maximum outdegree is unlimited.\n\
+\n\
+   S : allow that for every pair of vertices x,y at most one of the edges x-->y\n\
+       and y-->x may be present. By default both of them may be present in the same graph.\n\
+\n\
+\n\
+   T : Output directed graphs in T-code. This is a simple ASCII output format. Every line\n\
+       contains one graph. First the number of vertices, then the number of\n\
+       directed edges and then the list of directed edges with the start first\n\
+       and the end then. E.g.: 3 2 0 1 2 1 means 3 vertices, 2 directed edges:\n\
+       0-->1 and 2-->1\n\
+\n\
+   B : Output the directed graphs in a binary code. Every item of the code is an unsigned\n\
+       char. The first unsigned char is the number nv of vertices. The vertices are numbered 1..nv\n\
+       Then the list of vertices x for which there is a directed edge 1->x follow. This list is\n\
+       ended by a 0. Then the list of outgoing neighbours of 2 follows -- again ended with a 0, etc.\n\
+       The code is complete with the 0 ending the list of outgoing neighbours of nv.\n\
+\n\
+   C : Do really construct all the directed graphs in memory, but don't output them. This is not\n\
+       a big difference in case of restricted in- and outdegrees, because all that is done extra is that\n\
+       edges are directed instead of just keeping track of in- and out-degrees. This option is intended only\n\
+       for testing purposes to test also routines that are normally not used when counting. Things that would\n\
+       speed up the counting also in some cases of restricted in- and out-degrees -- like multiplying the\n\
+       possibilities of assigning directions to edges that can be assigned directions independent\n\
+       of each other (depending on the degrees of the endvertices and overlaps) -- are not included.\n\
+       In case of not restrictive bounds on the in- and out-degree it not really constructing the graphs\n\
+       can be considerably faster. In cases of restricted in- and out-degrees the only difference is that\n\
+       the graph isn't modified...\n\
+       The fact that in case of no output the graph is not modified is mainly to save time for the one\n\
+       case of waterclusters, where large numbers were determined. If large numbers (without output)\n\
+       for other cases shall be determined, one should think about adding the multiplication routines.\n\
+\n\
+   m : Read multicode instead of g6 code\n\
+\n\
+This program uses different labelling routines -- all based on the ideas of\n\
+\n\
+G. Brinkmann, Generating water clusters and other directed graphs,\n\
+Journal of Mathematical Chemistry 46, 1112--1121 (2009)\n"
+/*
+ * October 10, 2011: corrected error caused by overflow of 32bit int used as hashvalue.\n\
+ *
+ * Sep, 2012: PROCESS feature added by BDM.
+ */
 
 /* PROCESS feature
  *
@@ -67,7 +71,7 @@
  *
  * If SUMMARY is defined, it must expand as the name of a procedure
  * with prototype  void SUMMARY(void).  It is called at the end after
- * the normal summary. 
+ * the normal summary.
  */
 
 //#include<stdio.h>
@@ -500,7 +504,7 @@
 return 1;
 }
 
-
+#ifndef GTOOL_USAGEHELP_COMPATIBILITY
 void usage(char name[])
 {
 
@@ -518,6 +522,7 @@
   exit(1);
 
 }
+#endif
 
 /**********DECODE_TO_NAUTY****************************************************/
 
@@ -4013,6 +4018,15 @@
   int multicode=0, g6code=1;
   long long int last=0LL;
 
+#ifdef GTOOL_USAGEHELP_COMPATIBILITY
+	if (argc > 1 && (strcmp(argv[1],"-help") == 0
+                       || (strcmp(argv[1],"--help") == 0)))
+	{
+	    printf("Usage: %s\n\n%s",USAGE,HELPTEXT);
+	    exit(0);
+	}
+#endif
+
   if (sizeof(long long int)<8) 
     { 
       fprintf(stderr,"This may cause problems with the hashing function for large degree -- exit().\n");
@@ -4028,7 +4042,15 @@
 	  else  if (argv[i][0]=='B') direct_output=3;
 	    else  if (argv[i][0]=='S') double_allowed=0;
 	      else  if (argv[i][0]=='m') { g6code=0; multicode=1; }
-      else usage(argv[0]);
+      else {
+#ifdef GTOOL_USAGEHELP_COMPATIBILITY
+        fprintf(stderr,">E Usage: %s\n",USAGE);
+        fprintf(stderr,"Use watercluster2 -help to see a list of the options.\n");
+        exit(1);
+#else
+        usage(argv[0]);
+#endif
+				}
     }
 
 #ifdef PROCESS
--- a/genbg.c
+++ b/genbg.c
@@ -3,8 +3,7 @@
 /* TODO: consider colour swaps */
 
 #define USAGE \
-"genbg [-c -ugs -vq -lzF] [-Z#] [-D#] [-A] [-d#|-d#:#] [-D#|-D#:#] n1 n2 \n\
-                [mine[:maxe]] [res/mod] [file]"
+"genbg [-c -ugs -vq -lzF] [-Z#] [-D#] [-A] [-d#|-d#:#] [-D#|-D#:#] n1 n2 [mine[:maxe]] [res/mod] [file]"
 
 #define HELPTEXT \
 " Find all bicoloured graphs of a specified class.\n\
--- a/geng.c
+++ b/geng.c
@@ -5,8 +5,7 @@
 /* geng.c  version 2.7; B D McKay, Jan 2013. */
 
 #define USAGE \
-"geng [-cCmtfbd#D#] [-uygsnh] [-lvq] \n\
-              [-x#X#] n [mine[:maxe]] [res/mod] [file]"
+"geng [-cCmtfbd#D#] [-uygsnh] [-lvq] [-x#X#] n [mine[:maxe]] [res/mod] [file]"
 
 #define HELPTEXT \
 " Generate all graphs of a specified class.\n\
--- a/genrang.c
+++ b/genrang.c
@@ -1,8 +1,7 @@
 /* genrang.c  version 1.6; B D McKay, Mar 2, 2010 */
 
 #define USAGE \
-"genrang [-P#|-P#/#|-e#|-r#|-R#] [-l#] [-m#] [-t] [-a] \n" \
-"         [-s|-g] [-S#] [-q] n num [outfile]"
+"genrang [-P#|-P#/#|-e#|-r#|-R#] [-l#] [-m#] [-t] [-a] [-s|-g] [-S#] [-q] n num [outfile]"
 
 #define HELPTEXT \
 " Generate random graphs.\n\
